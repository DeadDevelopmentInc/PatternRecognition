

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Windows.Forms;
using Accord.Controls;
using Accord.Imaging;
using Accord.MachineLearning;
using Accord.MachineLearning.VectorMachines;
using Accord.MachineLearning.VectorMachines.Learning;
using Accord.Math;
using Accord.Statistics.Kernels;
using AForge;
using Accord;
using Accord.Math.Distances;
using Accord.Math.Optimization.Losses;

namespace Test
{
    /// <summary>
    ///   Image classification sample application.
    /// </summary>
    /// 
    /// <remarks>
    ///   This application uses the <see cref="BagOfVisualWords"/>,
    ///   <see cref="KernelSupportVectorMachines"/>, the <see cref="BinarySplit"/>
    ///   clustering algorithm and <see cref="SpeededUpRobustFeatures">SURF</see>
    ///   to perform image classification.
    /// </remarks>
    /// 
    public partial class MainWindow : Form
    {

        Dictionary<string, Bitmap> originalTrainImages;
        Dictionary<string, Bitmap> originalTestImages;

        Dictionary<string, Bitmap> originalImages;
        Dictionary<string, Bitmap> displayImages;

        // Here we will store our support vector machine that will be
        // used to classify the feature vectors generated by the BoW.

        MulticlassSupportVectorMachine<IKernel> ksvm;

        SupportVectorMachine<Gaussian> supportVectorMachine;

        // We use a MulticlassSupportVetorMachine<IKernel> because the
        // kernel can be selected at runtime. However, if we wanted the
        // machine to be as fast as possible, we could crewate the SVM
        // with the chosen kernel directly, such as:
        //
        // MulticlassSupportVectorMachine<Gaussian> ksvm;
        //


        public MainWindow()
        {
            InitializeComponent();
        }

        /// <summary>
        ///   This method just loads the image datasets into memory.
        /// </summary>
        /// 
        protected override void OnLoad(EventArgs e)
        {
            base.OnLoad(e);

            // Seed the number generator with a fixed number so results
            // are replicable across application runs. Comment the 
            // following line to generate truly random data splits.
            //
            Accord.Math.Random.Generator.Seed = 1;
            


            // Open Resources folder
            var path = new DirectoryInfo(Path.Combine(Application.StartupPath, "Resources"));

            // Create image list to load images into
            originalImages = new Dictionary<string, Bitmap>();
            displayImages = new Dictionary<string, Bitmap>();

            originalTestImages = new Dictionary<string, Bitmap>();
            originalTrainImages = new Dictionary<string, Bitmap>();

            ImageList imageList = new ImageList();
            imageList.ImageSize = new Size(64, 64);
            imageList.ColorDepth = ColorDepth.Depth32Bit;
            listView1.LargeImageList = imageList;

            int currentClassLabel = 0;

            // Now we will start loading the images from the image folder
            // and put them in the appropriate containers. We use dictionaries
            // so we can map each filename to their respective Bitmap object.

            // For every class folder
            foreach (DirectoryInfo classFolder in path.EnumerateDirectories())
            {
                string name = classFolder.Name;

                // Create two list view groups for each class.  Use 70%
                // of training instances and the remaining 30% as testing.
                ListViewGroup trainingGroup = listView1.Groups.Add(name + ".train", name + ".train");
                ListViewGroup testingGroup = listView1.Groups.Add(name + ".test", name + ".test");

                // Load the images from the directory that contains images for each class
                FileInfo[] files = GetFilesByExtensions(classFolder, ".jpg", ".tif").ToArray();

                // Shuffle the samples
                Vector.Shuffle(files);

                // For each file in the class folder
                for (int i = 0; i < files.Length; i++)
                {
                    FileInfo file = files[i];

                    Bitmap image = (Bitmap)Bitmap.FromFile(file.FullName);

                    string shortName = file.Name;
                    string imageKey = file.FullName;

                    imageList.Images.Add(imageKey, image);
                    originalImages.Add(imageKey, image);
                    displayImages.Add(imageKey, image);

                    ListViewItem item;
                    if ((i / (double)files.Length) < 0.7)
                    {
                        // Put the first 70% in training set
                        item = new ListViewItem(trainingGroup);
                        originalTrainImages.Add(imageKey, image);

                        item.Text = "Train " + i.ToString();
                    }
                    else
                    {
                        // Put the restant 30% in test set
                        item = new ListViewItem(testingGroup);
                        originalTestImages.Add(imageKey, image);
                        item.Text = "Test " + i.ToString();
                    }

                    item.ImageKey = imageKey;
                    item.Name = shortName;
                    // Use the tag object to store the class label of each image 
                    // - we will recover it from here later
                    item.Tag = new Tuple<double[], int>(null, currentClassLabel);

                    listView1.Items.Add(item);
                }

                currentClassLabel++;
            }
        }

        /// <summary>
        ///   This methods computes the Bag-of-Visual-Words with the training images.
        /// </summary>
        /// 
        private void buttonComputeBVW_Click(object sender, EventArgs e)
        {
            int numberOfWords = 64;


            Stopwatch sw1 = Stopwatch.StartNew();

            IBagOfWords<Bitmap> bow;

            // We will use SURF, so we can use a standard clustering
            // algorithm that is based on Euclidean distances. A good
            // algorithm for clustering codewords is the Binary Split
            // variant of the K-Means algorithm.

            // Create a Binary-Split clustering algorithm
            BinarySplit binarySplit = new BinarySplit(numberOfWords);

            // Create bag-of-words (BoW) with the given algorithm
            BagOfVisualWords surfBow = new BagOfVisualWords(binarySplit);

            // Compute the BoW codebook using training images only
            bow = surfBow.Learn(originalTrainImages.Values.ToArray());

            sw1.Stop();

            // Now that we have already created and computed the BoW model, we
            // will use it to extract representations for each of the images in
            // both training and testing sets.

            Stopwatch sw2 = Stopwatch.StartNew();

            // Extract features for all images
            foreach (ListViewItem item in listView1.Items)
            {
                // Get item image
                Bitmap image = originalImages[item.ImageKey] as Bitmap;

                // Get a feature vector representing this image
                double[] featureVector = (bow as ITransform<Bitmap, double[]>).Transform(image);

                // Represent it as a string so we can show it onscreen
                string featureString = featureVector.ToString(DefaultArrayFormatProvider.InvariantCulture);

                // Show it in the visual grid
                if (item.SubItems.Count == 2)
                    item.SubItems[1].Text = featureString;
                else item.SubItems.Add(featureString);

                // Retrieve the class labels, that we had stored in the Tag
                int classLabel = (item.Tag as Tuple<double[], int>).Item2;

                // Now, use the Tag to store the feature vector too
                item.Tag = Tuple.Create(featureVector, classLabel);
            }

            sw2.Stop();

            lbStatus.Text = "BoW constructed in " + sw1.Elapsed + "s. Features extracted in " + sw2.Elapsed + "s.";
        }


        /// <summary>
        ///   Creates the Support Vector Machines that will identify images based on
        ///   their Bag-of-Visual-Words feature vector representation.
        /// </summary>
        /// 
        private void buttonTrainning_Click(object sender, EventArgs e)
        {
            // Get the chosen kernel 
            IKernel kernel = getKernel();

            // Extract training parameters from the interface
            double complexity = 1;
            double tolerance = 0.01;
            int cacheSize = 1024;

            // Create the support vector machine learning algorithm
            /*var teacher = new MulticlassSupportVectorLearning<IKernel>()
            {
                Kernel = kernel,
                Learner = (param) =>
                {
                    return new SequentialMinimalOptimization<IKernel>()
                    {
                        Kernel = kernel,
                        Complexity = complexity,
                        Tolerance = tolerance,
                        CacheSize = cacheSize,
                    };
                }
            };*/

            var teacher = new OneclassSupportVectorLearning<Gaussian>()
            {
                Kernel = new Gaussian(0.2),
            };

            // Get the input and output data
            double[][] inputs;
            int[] outputs;
            getData(out inputs, out outputs);

            // Prepare to start learning
            lbStatus.Text = "Training the classifiers. This may take a (very) significant amount of time...";
            Application.DoEvents();

            Stopwatch sw = Stopwatch.StartNew();

            // Train the machines. It should take a while.
            //this.ksvm = teacher.Learn(inputs, outputs);
            this.supportVectorMachine = teacher.Learn(inputs);

            sw.Stop();

            // Compute the training error (accuracy, also known as zero-one-loss)
            //double error = new ZeroOneLoss(outputs).Loss(ksvm.Decide(inputs));

            /*lbStatus.Text = String.Format(
                "Training complete ({0}ms, {1}er). Click Classify to test the classifiers.",
                sw.ElapsedMilliseconds, error);*/

           

           
        }

        
        /// <summary>
        ///   Classifies images into one of the possible classes using the Support
        ///   Vector Machines learned in the previous steps. 
        /// </summary>
        /// 
        private void buttonClassify_Click(object sender, EventArgs e)
        {
            int trainingHits = 0;
            int trainingMiss = 0;

            int testingHits = 0;
            int testingMiss = 0;

            // For each image group (i.e. flowers, dolphins)
            foreach (ListViewGroup group in listView1.Groups)
            {
                // For each image item in the group
                foreach (ListViewItem item in group.Items)
                {
                    var info = item.Tag as Tuple<double[], int>;
                    double[] input = info.Item1;
                    int expected = info.Item2;

                    // Classify into one of the classes
                    //int actual = ksvm.Decide(input);
                    int actual = Convert.ToInt32(supportVectorMachine.Decide(input));

                    // Check if we did a correct classification
                    if (expected == actual)
                    {
                        // Yes, we did! Change color to green
                        item.BackColor = Color.LightGreen;
                        if (item.Group.Name.EndsWith(".train"))
                            trainingHits++;
                        else testingHits++;
                    }
                    else
                    {
                        // No, we didn't :( change to red
                        item.BackColor = Color.Firebrick;
                        if (item.Group.Name.EndsWith(".train"))
                            trainingMiss++;
                        else testingMiss++;
                    }
                }
            }

            int trainingTotal = trainingHits + trainingMiss;
            int testingTotal = testingHits + testingMiss;
            lbStatus.Text = String.Format("Classification complete. " +
               "Training: {0}/{1} ({2:00.00}%) hits. Testing: {3}/{4} ({5:00.00}%) hits.",
               trainingHits, trainingTotal, 100 * trainingHits / (double)(trainingTotal),
               testingHits, testingTotal, 100 * testingHits / (double)(testingTotal));
        }





        private void getData(out double[][] inputs, out int[] outputs)
        {
            List<double[]> inputList = new List<double[]>();
            List<int> outputList = new List<int>();

            foreach (ListViewGroup group in listView1.Groups)
            {
                if (group.Name.EndsWith(".train"))
                {
                    foreach (ListViewItem item in group.Items)
                    {
                        // Recover the class label and the feature vector
                        // that had been stored in the rows' Tag objects
                        var info = item.Tag as Tuple<double[], int>;
                        inputList.Add(info.Item1);
                        outputList.Add(info.Item2);
                    }
                }
            }

            inputs = inputList.ToArray();
            outputs = outputList.ToArray();
        }

        private IKernel getKernel()
        {
           return new HistogramIntersection(1, 1);

            throw new Exception();
        }
        

        public static IEnumerable<FileInfo> GetFilesByExtensions(DirectoryInfo dir, params string[] extensions)
        {
            if (extensions == null)
                throw new ArgumentNullException("extensions");
            IEnumerable<FileInfo> files = dir.EnumerateFiles();
            return files.Where(f => extensions.Contains(f.Extension));
        }
        
        private void toolStripMenuItem5_Click(object sender, EventArgs e)
        {
            Close();
        }
    }
}